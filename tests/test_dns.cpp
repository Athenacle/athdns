#include "dns.h"
#include "test.h"

#include <bitset>
#include <iostream>

using namespace dns;
using namespace dns_utils;
using namespace dns_values;

using std::bitset;

TEST(DNS, dnsTest1)
{
    uint8_t packet_bytes[] = {0x03, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x06, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x03,
                              0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01};

    auto dp = DnsPacket::fromDataBuffer(packet_bytes, sizeof packet_bytes);
    dp->parse();
    EXPECT_TRUE(dp->isQuery());
    EXPECT_FALSE(dp->isResponse());
    EXPECT_EQ(0x0100, dp->getFlag());
    EXPECT_EQ(dns_values::DNS_OPCODE_STAND_QUERY, dp->getOPCode());
    EXPECT_FALSE(dp->isAA());

    auto& q = dp->getQuery();
    EXPECT_STRCASEEQ("github.com", q.getName());
    EXPECT_EQ(q.getType(), Query::QUERY_TYPE_A);
    EXPECT_EQ(q.getClass(), Query::QUERY_CLASS_IN);

    delete dp;
}

TEST(DNS, dnsTest2_large_response)
{
    uint8_t packet_bytes[] = {
        0xe1, 0xda, 0x81, 0x80, 0x00, 0x01, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x05, 0x05, 0x71, 0x75,
        0x65, 0x72, 0x79, 0x04, 0x70, 0x72, 0x6f, 0x64, 0x03, 0x63, 0x6d, 0x73, 0x02, 0x72, 0x74,
        0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03, 0x63, 0x6f, 0x6d, 0x00,
        0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x02, 0x70, 0x00,
        0x2d, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x04, 0x70, 0x72, 0x6f, 0x64, 0x03, 0x63, 0x6d,
        0x73, 0x02, 0x72, 0x74, 0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03,
        0x63, 0x6f, 0x6d, 0x07, 0x65, 0x64, 0x67, 0x65, 0x6b, 0x65, 0x79, 0x03, 0x6e, 0x65, 0x74,
        0x00, 0xc0, 0x3d, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x4a, 0xd0, 0x00, 0x16, 0x06, 0x65,
        0x31, 0x31, 0x30, 0x37, 0x30, 0x01, 0x62, 0x0a, 0x61, 0x6b, 0x61, 0x6d, 0x61, 0x69, 0x65,
        0x64, 0x67, 0x65, 0xc0, 0x65, 0xc0, 0x76, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x9d,
        0x00, 0x04, 0x17, 0xc8, 0xe8, 0x8a, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96,
        0x52, 0x00, 0x0a, 0x07, 0x61, 0x31, 0x32, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f,
        0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x09, 0x06, 0x61, 0x36, 0x2d, 0x31,
        0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00,
        0x09, 0x06, 0x61, 0x31, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00,
        0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x6e, 0x73, 0x33, 0x2d, 0x31, 0x39, 0x34,
        0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07,
        0x61, 0x31, 0x33, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01,
        0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x6e, 0x73, 0x36, 0x2d, 0x31, 0x39, 0x34, 0xc0,
        0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x6e,
        0x73, 0x35, 0x2d, 0x31, 0x39, 0x34, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00,
        0x00, 0x96, 0x52, 0x00, 0x07, 0x04, 0x6c, 0x61, 0x72, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00,
        0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x06, 0x03, 0x6c, 0x61, 0x31, 0xc0, 0x7f,
        0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x06, 0x03, 0x6c, 0x61,
        0x33, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a,
        0x07, 0x61, 0x32, 0x38, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00,
        0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x61, 0x31, 0x31, 0x2d, 0x31, 0x39, 0x32,
        0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07,
        0x6e, 0x73, 0x37, 0x2d, 0x31, 0x39, 0x34, 0xc0, 0x7f, 0xc1, 0x53, 0x00, 0x01, 0x00, 0x01,
        0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0xb8, 0x1a, 0xa1, 0xc0, 0xc1, 0x65, 0x00, 0x01, 0x00,
        0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0x5f, 0x65, 0x24, 0xc0, 0xc1, 0x40, 0x00, 0x01,
        0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0x02, 0x10, 0x28, 0xc0, 0xc0, 0xd3, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x33, 0xf5, 0x00, 0x04, 0xc1, 0x6c, 0x58, 0x00, 0xc0, 0xbe,
        0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0x17, 0xd3, 0x85, 0xc0};

    auto dp = DnsPacket::fromDataBuffer(packet_bytes, sizeof packet_bytes);
    dp->parse();
    EXPECT_TRUE(dp->isResponse());
    EXPECT_EQ(dp->getFlag(), 0x8180);
    EXPECT_EQ(dp->getQuestionCount(), 1);
    EXPECT_EQ(dp->getAnswerRRCount(), 3);
    EXPECT_EQ(dp->getAuthorityRRCount(), 13);
    EXPECT_EQ(dp->getAdditionalRRCount(), 5);
    delete dp;
}


TEST(DNS_utils, bit_test)
{
    // bit_is_set tests with constant value
    uint8_t data = 0b01010101;
    EXPECT_TRUE(bit_is_set(data, 7));
    EXPECT_FALSE(bit_is_set(data, 6));
    EXPECT_TRUE(bit_is_set(data, 5));
    EXPECT_FALSE(bit_is_set(data, 4));
    EXPECT_TRUE(bit_is_set(data, 3));
    EXPECT_FALSE(bit_is_set(data, 2));
    EXPECT_TRUE(bit_is_set(data, 1));
    EXPECT_FALSE(bit_is_set(data, 0));

    // bit_set tests with constant value
    data = 0;
    bit_set(&data, 7, true);
    EXPECT_EQ(data, 0x1);
    bit_set(&data, 6, true);
    EXPECT_EQ(data, 0b11);

    data = test::random_value();
    for (int i = 0; i < 8; i++) {
        bit_set(&data, i, true);
    }
    EXPECT_EQ(data, 0xff);

    data = test::random_value();
    for (int i = 0; i < 8; i++) {
        bit_set(&data, i, false);
    }
    EXPECT_EQ(data, 0);

    //bit_is_set with random value, compare with std::bitset
    const int times = 100;

    for (int i = 0; i < times; i++) {
        uint8_t value = test::random_value() & 0xff;
        bitset<8> bs(value);
        for (int i = 0; i < 8; i++) {
            EXPECT_EQ(bit_is_set(value, i), bs.test(7 - i));
        }
        EXPECT_EQ(bs.to_ulong(), value);
    }

    //bit_set with random value, compare with std::bitset
    for (int i = 0; i < times; i++) {
        uint8_t value = 0;
        bitset<8> bs(0);
        for (uint32_t j = 0; j < test::random_value() % 100; j++) {
            bool set = test::random_value() % 2 == 0;
            int offset = test::random_value() % 8;
            bs.set(7 - offset, set);
            bit_set(&value, offset, set);
        }
        EXPECT_EQ(bs.to_ulong(), value);
    }
}

TEST(DNS_utils, query_string_generator)
{
    const int buffer_size = 256;
    uint8_t buffer[buffer_size];
    char eo[] = "example.com";
    char weo[] = "www.example.org";
    uint8_t weob[] = {0x03, 0x77, 0x77, 0x77, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
                      0x65, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01};

    uint8_t ecb[] = {0x07,
                     0x65,
                     0x78,
                     0x61,
                     0x6d,
                     0x70,
                     0x6c,
                     0x65,
                     0x03,
                     0x63,
                     0x6f,
                     0x6d,
                     0x00,
                     0x00,
                     0x01,
                     0x00,
                     0x01};

    memset(buffer, 0xcc, buffer_size);
    auto ret = query_string_generator(eo, buffer, buffer_size);
    EXPECT_EQ(ret, static_cast<int>(utils::strlen(eo) + 6));
    EXPECT_EQ(memcmp(ecb, buffer, sizeof(ecb)), 0);
    memset(buffer, 0xcc, buffer_size);
    ret = query_string_generator(weo, buffer, buffer_size);
    EXPECT_EQ(ret, static_cast<int>(utils::strlen(weo) + 6));
    EXPECT_EQ(memcmp(weob, buffer, sizeof(weob)), 0);
}

TEST(DNS_utils, dns_package_builder_BASE)
{
    dns_package_builder builder;
    uint8_t packet_bytes[] = {0x00, 0x00, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
                              0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01};
    builder.as_query().set_opcode(DNS_OPCODE_STAND_QUERY).set_RD().set_resp_AnswerAuthenicated();
    builder.set_query("example.org").set_id(0);

    DnsPacket* pack = builder.build();

    EXPECT_EQ(pack->get_size(), sizeof(packet_bytes));
    EXPECT_TRUE(memcmp(pack->get_data(), packet_bytes, sizeof(packet_bytes)) == 0);
    delete pack;

    dns_package_builder b2;
    uint8_t packet_bytes_1[] = {0x00, 0x00, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x03, 0x77, 0x77, 0x77, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70,
                                0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01};
    b2.as_query().set_opcode(DNS_OPCODE_STAND_QUERY).set_RD().set_resp_AnswerAuthenicated();
    b2.set_query("www.example.com").set_id(0);
    pack = b2.build();
    EXPECT_EQ(pack->get_size(), sizeof(packet_bytes_1));
    EXPECT_TRUE(memcmp(pack->get_data(), packet_bytes_1, sizeof(packet_bytes_1)) == 0);
    delete pack;
}

TEST(DNS_utils, dns_packet_builder_dns_packet)
{
    uint8_t packet_bytes[] = {0x98, 0x3d, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x03, 0x77, 0x77, 0x77, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70,
                              0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01};

    auto packet = DnsPacket::fromDataBuffer(packet_bytes, sizeof(packet_bytes));

    packet->parse();

    dns_package_builder builder;

    if (packet->isQuery()) {
        builder.as_query();
    } else {
        builder.as_response();
    }

    if (packet->isAA())
        builder.set_resp_AA();

    if (packet->isTC())
        builder.set_TC();

    if (packet->isRA())
        builder.set_resp_RA();

    if (packet->isRD())
        builder.set_RD();

    if (packet->isAD())
        builder.set_resp_AnswerAuthenicated();

    builder.set_id(packet->getQueryID()).set_query(packet->getQuery());
    auto np = builder.build();

    ASSERT_EQ(np->get_size(), packet->get_size());
    EXPECT_TRUE(memcmp(np->get_data(), packet->get_data(), np->get_size()) == 0);
}
