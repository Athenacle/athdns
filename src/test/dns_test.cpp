/*
 * Copyright (c) 2019 WangXiao <zjjhwxc@gmail.com>
 *
 * This Project is licensed under the MIT License.
 * Please refer to LICENSE file at root directory for more information
 *
 * athdns: simple DNS forwarder
 *
 */

// dns_test.cpp: tests for dns::DnsPacket

#include "test.h"

#include "dns.h"
#include "utils.h"

#include <bitset>
#include <iostream>
#include <typeinfo>

using namespace dns;
using namespace dns_utils;
using namespace dns_values;

using std::bitset;

TEST(DNS, dnsTest1)
{
    uint8_t packet_bytes[] = {0x03, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x06, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x03,
                              0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01};

    auto dp = DnsPacket::fromDataBuffer(packet_bytes, sizeof packet_bytes);
    dp->parse();
    EXPECT_TRUE(dp->isQuery());
    EXPECT_FALSE(dp->isResponse());
    EXPECT_EQ(0x0100, dp->getFlag());
    EXPECT_EQ(dns_values::DNS_OPCODE_STAND_QUERY, dp->getOPCode());
    EXPECT_FALSE(dp->isAA());

    auto& q = dp->getQuery();
    EXPECT_STRCASEEQ("github.com", q.getName());
    EXPECT_EQ(q.getType(), Query::QUERY_TYPE_A);
    EXPECT_EQ(q.getClass(), Query::QUERY_CLASS_IN);

    delete dp;
}

TEST(DNS, dnsTest2_large_response)
{
    uint8_t packet_bytes[] = {
        0xe1, 0xda, 0x81, 0x80, 0x00, 0x01, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x05, 0x05, 0x71, 0x75,
        0x65, 0x72, 0x79, 0x04, 0x70, 0x72, 0x6f, 0x64, 0x03, 0x63, 0x6d, 0x73, 0x02, 0x72, 0x74,
        0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03, 0x63, 0x6f, 0x6d, 0x00,
        0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x02, 0x70, 0x00,
        0x2d, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x04, 0x70, 0x72, 0x6f, 0x64, 0x03, 0x63, 0x6d,
        0x73, 0x02, 0x72, 0x74, 0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03,
        0x63, 0x6f, 0x6d, 0x07, 0x65, 0x64, 0x67, 0x65, 0x6b, 0x65, 0x79, 0x03, 0x6e, 0x65, 0x74,
        0x00, 0xc0, 0x3d, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x4a, 0xd0, 0x00, 0x16, 0x06, 0x65,
        0x31, 0x31, 0x30, 0x37, 0x30, 0x01, 0x62, 0x0a, 0x61, 0x6b, 0x61, 0x6d, 0x61, 0x69, 0x65,
        0x64, 0x67, 0x65, 0xc0, 0x65, 0xc0, 0x76, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x9d,
        0x00, 0x04, 0x17, 0xc8, 0xe8, 0x8a, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96,
        0x52, 0x00, 0x0a, 0x07, 0x61, 0x31, 0x32, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f,
        0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x09, 0x06, 0x61, 0x36, 0x2d, 0x31,
        0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00,
        0x09, 0x06, 0x61, 0x31, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00,
        0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x6e, 0x73, 0x33, 0x2d, 0x31, 0x39, 0x34,
        0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07,
        0x61, 0x31, 0x33, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01,
        0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x6e, 0x73, 0x36, 0x2d, 0x31, 0x39, 0x34, 0xc0,
        0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x6e,
        0x73, 0x35, 0x2d, 0x31, 0x39, 0x34, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00,
        0x00, 0x96, 0x52, 0x00, 0x07, 0x04, 0x6c, 0x61, 0x72, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00,
        0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x06, 0x03, 0x6c, 0x61, 0x31, 0xc0, 0x7f,
        0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x06, 0x03, 0x6c, 0x61,
        0x33, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a,
        0x07, 0x61, 0x32, 0x38, 0x2d, 0x31, 0x39, 0x32, 0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00,
        0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07, 0x61, 0x31, 0x31, 0x2d, 0x31, 0x39, 0x32,
        0xc0, 0x7f, 0xc0, 0x7f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x0a, 0x07,
        0x6e, 0x73, 0x37, 0x2d, 0x31, 0x39, 0x34, 0xc0, 0x7f, 0xc1, 0x53, 0x00, 0x01, 0x00, 0x01,
        0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0xb8, 0x1a, 0xa1, 0xc0, 0xc1, 0x65, 0x00, 0x01, 0x00,
        0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0x5f, 0x65, 0x24, 0xc0, 0xc1, 0x40, 0x00, 0x01,
        0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0x02, 0x10, 0x28, 0xc0, 0xc0, 0xd3, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x33, 0xf5, 0x00, 0x04, 0xc1, 0x6c, 0x58, 0x00, 0xc0, 0xbe,
        0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x96, 0x52, 0x00, 0x04, 0x17, 0xd3, 0x85, 0xc0};

    auto dp = DnsPacket::fromDataBuffer(packet_bytes, sizeof packet_bytes);
    dp->parse();
    EXPECT_TRUE(dp->isResponse());
    EXPECT_EQ(dp->getFlag(), 0x8180);
    EXPECT_EQ(dp->getQuestionCount(), 1);
    EXPECT_EQ(dp->getAnswerRRCount(), 3);
    EXPECT_EQ(dp->getAuthorityRRCount(), 13);
    EXPECT_EQ(dp->getAdditionalRRCount(), 5);
    delete dp;
}


TEST(DNS_utils, bit_test)
{
    // bit_is_set tests with constant value
    uint8_t data = 0b01010101;
    EXPECT_TRUE(bit_is_set(data, 7));
    EXPECT_FALSE(bit_is_set(data, 6));
    EXPECT_TRUE(bit_is_set(data, 5));
    EXPECT_FALSE(bit_is_set(data, 4));
    EXPECT_TRUE(bit_is_set(data, 3));
    EXPECT_FALSE(bit_is_set(data, 2));
    EXPECT_TRUE(bit_is_set(data, 1));
    EXPECT_FALSE(bit_is_set(data, 0));

    // bit_set tests with constant value
    data = 0;
    bit_set(&data, 7, true);
    EXPECT_EQ(data, 0x1);
    bit_set(&data, 6, true);
    EXPECT_EQ(data, 0b11);

    data = test::random_value();
    for (int i = 0; i < 8; i++) {
        bit_set(&data, i, true);
    }
    EXPECT_EQ(data, 0xff);

    data = test::random_value();
    for (int i = 0; i < 8; i++) {
        bit_set(&data, i, false);
    }
    EXPECT_EQ(data, 0);

    //bit_is_set with random value, compare with std::bitset
    const int times = 100;

    for (int i = 0; i < times; i++) {
        uint8_t value = test::random_value() & 0xff;
        bitset<8> bs(value);
        for (int i = 0; i < 8; i++) {
            EXPECT_EQ(bit_is_set(value, i), bs.test(7 - i));
        }
        EXPECT_EQ(bs.to_ulong(), value);
    }

    //bit_set with random value, compare with std::bitset
    for (int i = 0; i < times; i++) {
        uint8_t value = 0;
        bitset<8> bs(0);
        for (uint32_t j = 0; j < test::random_value() % 100; j++) {
            bool set = test::random_value() % 2 == 0;
            int offset = test::random_value() % 8;
            bs.set(7 - offset, set);
            bit_set(&value, offset, set);
        }
        EXPECT_EQ(bs.to_ulong(), value);
    }
}

TEST(DNS_utils, query_string_generator)
{
    const int buffer_size = 256;
    uint8_t buffer[buffer_size];
    char eo[] = "example.com";
    char weo[] = "www.example.org";

    uint8_t ecb[] = {0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00};
    uint8_t weob[] = {0x03,
                      0x77,
                      0x77,
                      0x77,
                      0x07,
                      0x65,
                      0x78,
                      0x61,
                      0x6d,
                      0x70,
                      0x6c,
                      0x65,
                      0x03,
                      0x6f,
                      0x72,
                      0x67,
                      0x00};

    memset(buffer, 0xcc, buffer_size);
    auto ret = query_string_generator(eo, buffer, buffer_size);
    EXPECT_EQ(ret, static_cast<int>(utils::strlen(eo) + 2));
    EXPECT_EQ(memcmp(ecb, buffer, sizeof(ecb)), 0);
    memset(buffer, 0xcc, buffer_size);
    ret = query_string_generator(weo, buffer, buffer_size);
    EXPECT_EQ(ret, static_cast<int>(utils::strlen(weo) + 2));
    EXPECT_EQ(memcmp(weob, buffer, sizeof(weob)), 0);
}

TEST(DNS_utils, dns_package_builder_BASE)
{
    dns_package_builder builder;
    uint8_t packet_bytes[] = {0x00, 0x00, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
                              0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01};
    builder.as_query().set_opcode(DNS_OPCODE_STAND_QUERY).set_RD().set_resp_AnswerAuthenicated();
    builder.set_query("example.org").set_id(0);

    DnsPacket* pack = builder.build();

    EXPECT_EQ(pack->get_size(), sizeof(packet_bytes));
    EXPECT_TRUE(memcmp(pack->get_data(), packet_bytes, sizeof(packet_bytes)) == 0);
    delete pack;

    dns_package_builder b2;
    uint8_t packet_bytes_1[] = {0x00, 0x00, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x03, 0x77, 0x77, 0x77, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70,
                                0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01};
    b2.as_query().set_opcode(DNS_OPCODE_STAND_QUERY).set_RD().set_resp_AnswerAuthenicated();
    b2.set_query("www.example.com").set_id(0);
    pack = b2.build();
    EXPECT_EQ(pack->get_size(), sizeof(packet_bytes_1));
    EXPECT_TRUE(memcmp(pack->get_data(), packet_bytes_1, sizeof(packet_bytes_1)) == 0);
    delete pack;
}

TEST(DNS_utils, dns_packet_builder_dns_packet)
{
    uint8_t packet_bytes[] = {0x98, 0x3d, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x03, 0x77, 0x77, 0x77, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70,
                              0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01};

    auto packet = DnsPacket::fromDataBuffer(packet_bytes, sizeof(packet_bytes));

    packet->parse();

    dns_package_builder builder;

    if (packet->isQuery()) {
        builder.as_query();
    } else {
        builder.as_response();
    }

    if (packet->isAA())
        builder.set_resp_AA();

    if (packet->isTC())
        builder.set_TC();

    if (packet->isRA())
        builder.set_resp_RA();

    if (packet->isRD())
        builder.set_RD();

    if (packet->isAD())
        builder.set_resp_AnswerAuthenicated();

    builder.set_id(packet->getQueryID()).set_query(packet->getQuery());
    auto np = builder.build();

    ASSERT_EQ(np->get_size(), packet->get_size());
    EXPECT_TRUE(memcmp(np->get_data(), packet->get_data(), np->get_size()) == 0);
    delete packet;
    delete np;
}

TEST(DNS_utils, query_string_parser)
{
    uint8_t eo[] = {0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x6f, 0x72, 0x67, 0x00};
    char eos[] = "example.org";

    auto eot = query_string_parser(eo);
    EXPECT_TRUE(utils::strcmp(eot, eos) == 0);
    utils::strfree(eot);

    uint8_t wwweo[] = {0x03, 0x77, 0x77, 0x77, 0x03, 0x77, 0x77, 0x77, 0x03, 0x77, 0x77, 0x77, 0x07,
                       0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x6f, 0x72, 0x67, 0x00};
    char wwweos[] = "www.www.www.example.org";

    eot = query_string_parser(wwweo);
    EXPECT_TRUE(utils::strcmp(eot, wwweos) == 0);
    utils::strfree(eot);
}

TEST(DNS_utils, ip_string_to_uint32)
{
    char ip1[] = "1.2.3.4";
    char ip2[] = "255.255.255.255";
    char ip3[] = "0.0.0.0";
    char ip4[] = "0.0.0.";
    char ip5[] = "1.2.3.4.5";
    char ip6[] = "256.2.3.4";

    uint32_t tval;
    EXPECT_FALSE(ip_string_to_uint32(ip4, tval));
    EXPECT_FALSE(ip_string_to_uint32(ip5, tval));
    EXPECT_FALSE(ip_string_to_uint32(ip6, tval));

    uint32_t i1 = 1 << 24 | 2 << 16 | 3 << 8 | 4;
    uint32_t i2 = 0xffffffff;
    uint32_t i3 = 0;

    uint32_t r1, r2, r3;

    EXPECT_TRUE(ip_string_to_uint32(ip1, r1));
    EXPECT_TRUE(ip_string_to_uint32(ip2, r2));
    EXPECT_TRUE(ip_string_to_uint32(ip3, r3));

    EXPECT_EQ(r1, i1);
    EXPECT_EQ(r2, i2);
    EXPECT_EQ(r3, i3);
}


TEST(DNS, generate_record_node)
{
    // example.org -> 93.184.216.34
    uint8_t packet_bytes[] = {
        0x14, 0x2d, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x65, 0x78,
        0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0,
        0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x0d, 0x40, 0x00, 0x04, 0x5d, 0xb8, 0xd8, 0x22};

    DnsPacket* pack = DnsPacket::fromDataBuffer(packet_bytes, sizeof(packet_bytes));
    auto node = pack->generate_record_node();
    record_node_A* p;

    uint32_t ttl;
    uint16_t type, clazz, length;
    node->get_value(ttl, type, clazz, length);

    EXPECT_EQ(ttl, 68928u);
    EXPECT_EQ(type, DNS_TYPE_A);
    EXPECT_EQ(clazz, DNS_CLASS_IN);
    EXPECT_EQ(length, 4);

    ASSERT_NO_THROW({ p = dynamic_cast<record_node_A*>(node); });
    char ip[] = "93.184.216.34";
    uint32_t iip;
    EXPECT_TRUE(ip_string_to_uint32(ip, iip));
    ip_address addr(iip);
    ASSERT_TRUE(p->operator==(addr));
    ASSERT_TRUE(node->operator==("example.org"));
    ASSERT_EQ(node->next_count(), 1);

    delete pack;
    delete node;
}

TEST(DNS, generate_record_node_CNAME)
{
    // git.athenacle.xyz -> CNAME master.athenacle.xyz -> IP 10.70.20.11
    uint8_t buf[] = {0x1b, 0xd9, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
                     0x03, 0x67, 0x69, 0x74, 0x09, 0x61, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x63,
                     0x6c, 0x65, 0x03, 0x78, 0x79, 0x7a, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0,
                     0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x09, 0x06,
                     0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0xc0, 0x10, 0xc0, 0x2f, 0x00, 0x01,
                     0x00, 0x01, 0x00, 0x01, 0x51, 0x80, 0x00, 0x04, 0x0a, 0x46, 0x14, 0x0b};

    char name_1[] = "git.athenacle.xyz";
    char name_2[] = "master.athenacle.xyz";

    DnsPacket* pack = DnsPacket::fromDataBuffer(buf, sizeof(buf));
    auto node = pack->generate_record_node();
    record_node_CNAME* cname;

    ASSERT_NO_THROW({ cname = dynamic_cast<record_node_CNAME*>(node); });
    ASSERT_EQ(cname->next_count(), 2);

    ASSERT_STREQ(cname->get_actual_name(), name_2);
    ASSERT_STREQ(cname->get_name(), name_1);

    delete node;
    delete pack;
}
